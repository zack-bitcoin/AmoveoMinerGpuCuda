%%%-------------------------------------------------------------------
%% @doc propPoolExploit top level supervisor.
%% @end
%%%-------------------------------------------------------------------

-module(propPoolExploit_sup).

-behaviour(supervisor).

%% API
-export([start_link/0]).

%% Supervisor callbacks
-export([init/1]).
-define(CHILD(I, Type), {I, {I, start_link, []}, permanent, 5000, Type, [I]}).
-define(SERVER, ?MODULE).
-define(keys, []).
child_killer([]) -> [];
child_killer([H|T]) -> 
    supervisor:terminate_child(testnet_sup, H),
    child_killer(T).
stop() -> child_killer(?keys).
child_maker([]) -> [];
child_maker([H|T]) -> [?CHILD(H, worker)|child_maker(T)].

%%====================================================================
%% API functions
%%====================================================================

start_link() ->
    supervisor:start_link({local, ?SERVER}, ?MODULE, []).

%%====================================================================
%% Supervisor callbacks
%%====================================================================
update_children([]) -> [];
update_children([{ID, _}|T]) ->
    [update_child(ID)|update_children(T)].
update_child(ID) -> 
    ID2 = list_to_atom(atom_to_list(ID) ++ "_updater"),
    {ID2, {updater, start_link, [ID, ID2]}, permanent, 5000, worker, [updater]}.
pool_children([]) -> [];
pool_children([{ID, Location}|T]) ->
    [pool_child(ID, Location)|pool_children(T)].
pool_child(ID, Address) -> {ID, {mining_pool, start_link, [Address, ID]}, permanent, 5000, worker, [mining_pool]}.
%% Child :: {Id,StartFunc,Restart,Shutdown,Type,Modules}
init([]) ->
    Children = child_maker(?keys),
    PC = pool_children(config:pools()),
    UC = update_children(config:pools()),
    {ok, { {one_for_all, 50000, 1}, PC ++ UC} }.
