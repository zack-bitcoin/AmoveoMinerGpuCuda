-module(updater).
-behaviour(gen_server).
-export([start_link/2,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2, 
	 update/1, new_pool/1, update_all/0]).
-define(REFRESH, 3000).%How often in miliseconds to update data from the mining pools.
-record(pool, {location, header_height = 0, block_height = 0, time = {0,0,0}}).
init(ID) -> {ok, ID}.
start_link(A, ID) -> gen_server:start_link({global, ID}, ?MODULE, A, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:format("died!"), ok.
handle_info(_, X) -> {noreply, X}.
handle_cast(update, ID) -> 
    X = mining_pool:read(ID),
    T = X#pool.time,
    L = X#pool.location,
    TD = timer:now_diff(erlang:timestamp(), T),
    X2 = if
	     TD > (?REFRESH * 1000) ->
		 Msg = {height},%block:height
		 BlockHeight = element(2, talker:talk(Msg, L)),
		 Msg2 = {header},%header:top
		 HeaderHeight = element(2, (element(2, talker:talk(Msg2, L)))),
		 X#pool{time = erlang:timestamp(), 
		       header_height = max(X#pool.header_height,
					  HeaderHeight),
		       block_height = max(X#pool.block_height,
					 BlockHeight)};
	     true ->
		 X
	 end,
    mining_pool:write(ID, X2),
    {noreply, ID};
handle_cast(_, X) -> {noreply, X}.
handle_call(_, _From, X) -> {reply, X, X}.
update(N) -> 
    ID2 = list_to_atom(atom_to_list(N) ++ "_updater"),
    gen_server:cast({global, ID2}, update).
update_all() ->
    lists:map(fun(X) -> update(X) end,
	      config:pool_ids()).
		      
new_pool(L) -> #pool{location = L}.
